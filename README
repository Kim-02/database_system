mmap_read.h는 mmap을 이용하여 입력 파일을 메모리에 매핑한다.
이는 fread/fgets처럼 사용자 버퍼에 반복적으로 읽어들이는 방식보다
시스템콜 오버헤드가 적고 페이지 캐시를 그대로 활용할 수 있어 더 빠르게 동작한다.

실험에서는 비신장 가변길이 블로킹을 사용하기 때문에
레코드가 블록 경계를 넘어가면 안 된다. 
따라서 각 블록은 [header + data] 구조로 이루어지며
header에서 남은 공간을 관리하여 레코드 삽입 여부를 결정한다.

블록이 가득 차서 flush가 일어나는 횟수는 
DBMS에서 페이지 I/O가 발생하는 횟수와 동일한 의미를 가진다.
블록 크기가 작으면 flush 횟수가 증가하여 페이지 생성 및 디스크 접근 오버헤드가 증가하고,
블록 크기를 키우면 flush 횟수가 줄어들어 I/O 성능이 향상된다.

실험 결과에서도 PageSize를 2048에서 4096으로 늘리자
flush 횟수가 약 절반으로 감소하였고,
전체 처리 속도는 15~20% 향상되는 것을 확인할 수 있었다.
캐시 효과 때문에 개별 실행 결과는 편차가 있으므로
여러 번 반복 측정하여 평균값을 사용하는 것이 필수적이다.

11/17 수정 
mmap을 사용하지 않고 read방식을 사용 -> 이게 더 메모리 친화적으로 접근하는 방식이고 IO 시간 차이도 더
잘 나오는 방법임
table_split 헤더를 추가했음 -> difine에 정의된 페이지 사이즈별로 블록을 하나의 파일에 써주는 것
나중에 읽을 때는 나눈 페이지 사이즈를 기준으로 fseek하면 됨

11/20 수정
main에 일단 모든 코드 몰아넣었음 -> 모듈화 예정
사용 코드

./main.out 메모리제한(MB) 파일명 메타데이터 파일블록크기 ... 조인키
./main.out 2 part.tbl "partkey,name,mfgr,brand,type,size,container,retailprice,comment" 10000 partsupp.tbl "partkey,suppkey,availqty,supplycost,comment" 10000 partkey
part.tbl, partsupp.tbl 파일 TPC에서 가져와서 사용하면 됨